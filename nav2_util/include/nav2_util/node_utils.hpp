// Copyright (c) 2019 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef NAV2_UTIL__NODE_UTILS_HPP_
#define NAV2_UTIL__NODE_UTILS_HPP_

#include <vector>
#include <string>
#include "rclcpp/rclcpp.hpp"
#include "rcl_interfaces/srv/list_parameters.hpp"

namespace nav2_util
{

/// Replace invalid characters in a potential node name
/**
 * There is frequently a need to create internal nodes. They must have a name,
 * and commonly the name is based on some parameter related to the node's
 * purpose. However, only alphanumeric characters and '_' are allowed in node
 * names. This function replaces any invalid character with a '_'
 *
 * \param[in] potential_node_name Potential name but possibly with invalid charaters.
 * \return A copy of the input string but with non-alphanumeric characters replaced with '_'
 */

/// 替换潜在节点名称中的非法字符
/**
 * 经常需要创建内部节点。它们必须有一个名称，
 * 通常这个名称是基于与节点目的相关的某些参数。然而，
 * 节点名称中只允许使用字母数字字符和'_'。此函数将任何非法字符替换为'_'
 *
 * \param[in] potential_node_name 潜在的节点名称，但可能包含非法字符。
 * \return 输入字符串的副本，但所有非字母数字字符都被替换为'_'
 */
std::string sanitize_node_name(const std::string & potential_node_name);

/// Concatenate two namespaces to produce an absolute namespace
/**
 * \param[in] top_ns The namespace to place first
 * \param[in] sub_ns The namespace to place after top_ns
 * \return An absolute namespace starting with "/"
*/

/// 将两个命名空间连接起来生成一个绝对命名空间
/**
 * \param[in] top_ns 放在前面的命名空间
 * \param[in] sub_ns 放在top_ns之后的命名空间
 * \return 以“/”开头的绝对命名空间
 */
std::string add_namespaces(const std::string & top_ns, const std::string & sub_ns = "");

/// Add some random characters to a node name to ensure it is unique in the system
/**
 * There are utility classes that create an internal private node to interact
 * with the system. These private nodes are given a generated name. If multiple
 * clients end up using the same service, there is the potential for node name
 * conflicts. To ensure node names are globally unique, this appends some random
 * numbers to the end of the prefix.
 *
 * \param[in] prefix A string to help understand the purpose of the node.
 * \return A copy of the prefix + '_' + 8 random digits. eg. prefix_12345678
 */

/// 为节点名称添加一些随机字符，以确保其在系统中的唯一性
/**
 * 有一些实用工具类会创建一个内部私有节点来与系统交互。
 * 这些私有节点被赋予一个生成的名称。如果多个客户端使用相同的服务，
 * 则存在节点名称冲突的可能。为了确保节点名称在全局上是唯一的，
 * 此函数会在前缀后追加一些随机数字。
 *
 * \param[in] prefix 字符串，用来帮助理解节点的目的。
 * \return 前缀 + '_' + 8位随机数字的组合。例如：prefix_12345678
 */
std::string generate_internal_node_name(const std::string & prefix = "");

/// Creates a node with a name as generated by generate_internal_node_name
/**
 *  Creates a node with the following settings:
 *  - name generated by generate_internal_node_name
 *  - no parameter services
 *  - no parameter event publisher
 *
 * \param[in] prefix A string to help understand the purpose of the node.
 * \return A shared_ptr to the node.
 */

/// 创建一个由 generate_internal_node_name 生成名称的节点
/**
 * 创建一个具有以下设置的节点：
 *  - 名称由 generate_internal_node_name 生成
 *  - 没有参数服务
 *  - 没有参数事件发布器
 *
 * \param[in] prefix 字符串，用来帮助理解节点的目的。
 * \return 指向节点的 shared_ptr。
 */
rclcpp::Node::SharedPtr generate_internal_node(const std::string & prefix = "");

/// Generates a pseudo random string of digits.
/**
 * Generates pseudo random digits by converting the current system time to a
 * string. This means that any length more than 8 or so digits will just get
 * padded with zeros and doesn't add any additional randomness.
 *
 * \param[in] len Length of the output string
 * \return A string containing random digits
 */

/// 生成一个伪随机数字字符串。
/**
 * 通过将当前系统时间转换为字符串来生成伪随机数字。
 * 这意味着，如果输出字符串长度超过大约8位，其余的位数将用零填充，
 * 并不会增加任何额外的随机性。
 *
 * \param[in] len 输出字符串的长度
 * \return 包含随机数字的字符串
 */
std::string time_to_string(size_t len);

/// Declares static ROS2 parameter and sets it to a given value if it was not already declared
/* Declares static ROS2 parameter and sets it to a given value
 * if it was not already declared.
 *
 * \param[in] node A node in which given parameter to be declared
 * \param[in] param_name The name of parameter
 * \param[in] default_value Parameter value to initialize with
 * \param[in] parameter_descriptor Parameter descriptor (optional)
 */

/// 声明静态ROS2参数，并在其未被声明时将其设置为给定值
/* 声明静态ROS2参数，并在其未被声明时将其设置为给定值。
 *
 * \param[in] node 在其中声明给定参数的节点
 * \param[in] param_name 参数的名称
 * \param[in] default_value 用于初始化的参数值
 * \param[in] parameter_descriptor 参数描述符（可选）
 */
template<typename NodeT>
void declare_parameter_if_not_declared(
  NodeT node,
  const std::string & param_name,
  const rclcpp::ParameterValue & default_value,
  const rcl_interfaces::msg::ParameterDescriptor & parameter_descriptor =
  rcl_interfaces::msg::ParameterDescriptor())
{
  if (!node->has_parameter(param_name)) {
    node->declare_parameter(param_name, default_value, parameter_descriptor);
  }
}

/// Declares static ROS2 parameter with given type if it was not already declared
/* Declares static ROS2 parameter with given type if it was not already declared.
 *
 * \param[in] node A node in which given parameter to be declared
 * \param[in] param_type The type of parameter
 * \param[in] default_value Parameter value to initialize with
 * \param[in] parameter_descriptor Parameter descriptor (optional)
 */

/// 如果尚未声明，则声明具有给定类型的静态ROS2参数
/* 如果尚未声明，则声明具有给定类型的静态ROS2参数。
 *
 * \param[in] node 在其中声明给定参数的节点
 * \param[in] param_type 参数的类型
 * \param[in] default_value 用于初始化的参数值
 * \param[in] parameter_descriptor 参数描述符（可选）
 */
template<typename NodeT>
void declare_parameter_if_not_declared(
  NodeT node,
  const std::string & param_name,
  const rclcpp::ParameterType & param_type,
  const rcl_interfaces::msg::ParameterDescriptor & parameter_descriptor =
  rcl_interfaces::msg::ParameterDescriptor())
{
  if (!node->has_parameter(param_name)) {
    node->declare_parameter(param_name, param_type, parameter_descriptor);
  }
}

/// Gets the type of plugin for the selected node and its plugin
/**
 * Gets the type of plugin for the selected node and its plugin.
 * Actually seeks for the value of "<plugin_name>.plugin" parameter.
 *
 * \param[in] node Selected node
 * \param[in] plugin_name The name of plugin the type of which is being searched for
 * \return A string containing the type of plugin (the value of "<plugin_name>.plugin" parameter)
 */

/// 获取所选节点及其插件的插件类型
/**
 * 获取所选节点及其插件的插件类型。
 * 实际上是寻找“<plugin_name>.plugin”参数的值。
 *
 * \param[in] node 所选节点
 * \param[in] plugin_name 正在搜索其类型的插件的名称
 * \return 包含插件类型的字符串（“<plugin_name>.plugin”参数的值）
 */
template<typename NodeT>
std::string get_plugin_type_param(
  NodeT node,
  const std::string & plugin_name)
{
  declare_parameter_if_not_declared(node, plugin_name + ".plugin", rclcpp::PARAMETER_STRING);
  std::string plugin_type;
  try {
    if (!node->get_parameter(plugin_name + ".plugin", plugin_type)) {
      RCLCPP_FATAL(
        node->get_logger(), "Can not get 'plugin' param value for %s", plugin_name.c_str());
      exit(-1);
    }
  } catch (rclcpp::exceptions::ParameterUninitializedException & ex) {
    RCLCPP_FATAL(node->get_logger(), "'plugin' param not defined for %s", plugin_name.c_str());
    exit(-1);
  }

  return plugin_type;
}

/**
 * @brief A method to copy all parameters from one node (parent) to another (child).
 * May throw parameter exceptions in error conditions
 * @param parent Node to copy parameters from
 * @param child Node to copy parameters to
 */

/**
 * @brief 从一个节点（父节点）复制所有参数到另一个节点（子节点）的方法。
 * 在错误条件下可能会抛出参数异常
 * @param parent 从中复制参数的节点
 * @param child 复制参数到的节点
 */
template<typename NodeT1, typename NodeT2>
void copy_all_parameters(const NodeT1 & parent, const NodeT2 & child)
{
  using Parameters = std::vector<rclcpp::Parameter>;
  std::vector<std::string> param_names = parent->list_parameters({}, 0).names;
  Parameters params = parent->get_parameters(param_names);
  for (Parameters::const_iterator iter = params.begin(); iter != params.end(); ++iter) {
    if (!child->has_parameter(iter->get_name())) {
      child->declare_parameter(iter->get_name(), iter->get_parameter_value());
    }
  }
}

}  // namespace nav2_util

#endif  // NAV2_UTIL__NODE_UTILS_HPP_
